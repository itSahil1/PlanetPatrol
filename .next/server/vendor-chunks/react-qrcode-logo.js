"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-qrcode-logo";
exports.ids = ["vendor-chunks/react-qrcode-logo"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-qrcode-logo/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/react-qrcode-logo/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QRCode = void 0;\nvar isEqual = __webpack_require__(/*! lodash.isequal */ \"(ssr)/./node_modules/lodash.isequal/index.js\");\nvar qrGenerator = __webpack_require__(/*! qrcode-generator */ \"(ssr)/./node_modules/qrcode-generator/qrcode.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar QRCode = /** @class */ (function (_super) {\n    __extends(QRCode, _super);\n    function QRCode(props) {\n        var _this = _super.call(this, props) || this;\n        _this.canvasRef = React.createRef();\n        return _this;\n    }\n    QRCode.prototype.download = function (fileType, fileName) {\n        if (this.canvasRef.current) {\n            var mimeType = void 0;\n            switch (fileType) {\n                case 'jpg':\n                    mimeType = 'image/jpeg';\n                    break;\n                case 'webp':\n                    mimeType = 'image/webp';\n                    break;\n                case 'png':\n                default:\n                    mimeType = 'image/png';\n                    break;\n            }\n            var url = this.canvasRef.current.toDataURL(mimeType, 1.0);\n            var link = document.createElement('a');\n            link.download = fileName !== null && fileName !== void 0 ? fileName : 'react-qrcode-logo';\n            link.href = url;\n            link.click();\n        }\n    };\n    QRCode.prototype.utf16to8 = function (str) {\n        var out = '', i, c;\n        var len = str.length;\n        for (i = 0; i < len; i++) {\n            c = str.charCodeAt(i);\n            if ((c >= 0x0001) && (c <= 0x007F)) {\n                out += str.charAt(i);\n            }\n            else if (c > 0x07FF) {\n                out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));\n                out += String.fromCharCode(0x80 | ((c >> 6) & 0x3F));\n                out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F));\n            }\n            else {\n                out += String.fromCharCode(0xC0 | ((c >> 6) & 0x1F));\n                out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F));\n            }\n        }\n        return out;\n    };\n    /**\n     * Draw a rounded square in the canvas\n     */\n    QRCode.prototype.drawRoundedSquare = function (lineWidth, x, y, size, color, radii, fill, ctx) {\n        ctx.lineWidth = lineWidth;\n        ctx.fillStyle = color;\n        ctx.strokeStyle = color;\n        // Adjust coordinates so that the outside of the stroke is aligned to the edges\n        y += lineWidth / 2;\n        x += lineWidth / 2;\n        size -= lineWidth;\n        if (!Array.isArray(radii)) {\n            radii = [radii, radii, radii, radii];\n        }\n        // Radius should not be greater than half the size or less than zero\n        radii = radii.map(function (r) {\n            r = Math.min(r, size / 2);\n            return (r < 0) ? 0 : r;\n        });\n        var rTopLeft = radii[0] || 0;\n        var rTopRight = radii[1] || 0;\n        var rBottomRight = radii[2] || 0;\n        var rBottomLeft = radii[3] || 0;\n        ctx.beginPath();\n        ctx.moveTo(x + rTopLeft, y);\n        ctx.lineTo(x + size - rTopRight, y);\n        if (rTopRight)\n            ctx.quadraticCurveTo(x + size, y, x + size, y + rTopRight);\n        ctx.lineTo(x + size, y + size - rBottomRight);\n        if (rBottomRight)\n            ctx.quadraticCurveTo(x + size, y + size, x + size - rBottomRight, y + size);\n        ctx.lineTo(x + rBottomLeft, y + size);\n        if (rBottomLeft)\n            ctx.quadraticCurveTo(x, y + size, x, y + size - rBottomLeft);\n        ctx.lineTo(x, y + rTopLeft);\n        if (rTopLeft)\n            ctx.quadraticCurveTo(x, y, x + rTopLeft, y);\n        ctx.closePath();\n        ctx.stroke();\n        if (fill) {\n            ctx.fill();\n        }\n    };\n    /**\n     * Draw a single positional pattern eye.\n     */\n    QRCode.prototype.drawPositioningPattern = function (ctx, cellSize, offset, row, col, color, radii) {\n        if (radii === void 0) { radii = [0, 0, 0, 0]; }\n        var lineWidth = Math.ceil(cellSize);\n        var radiiOuter;\n        var radiiInner;\n        if (typeof radii !== 'number' && !Array.isArray(radii)) {\n            radiiOuter = radii.outer || 0;\n            radiiInner = radii.inner || 0;\n        }\n        else {\n            radiiOuter = radii;\n            radiiInner = radiiOuter;\n        }\n        var colorOuter;\n        var colorInner;\n        if (typeof color !== 'string') {\n            colorOuter = color.outer;\n            colorInner = color.inner;\n        }\n        else {\n            colorOuter = color;\n            colorInner = color;\n        }\n        var y = (row * cellSize) + offset;\n        var x = (col * cellSize) + offset;\n        var size = cellSize * 7;\n        // Outer box\n        this.drawRoundedSquare(lineWidth, x, y, size, colorOuter, radiiOuter, false, ctx);\n        // Inner box\n        size = cellSize * 3;\n        y += cellSize * 2;\n        x += cellSize * 2;\n        this.drawRoundedSquare(lineWidth, x, y, size, colorInner, radiiInner, true, ctx);\n    };\n    ;\n    /**\n     * Is this dot inside a positional pattern zone.\n     */\n    QRCode.prototype.isInPositioninZone = function (col, row, zones) {\n        return zones.some(function (zone) { return (row >= zone.row && row <= zone.row + 7 &&\n            col >= zone.col && col <= zone.col + 7); });\n    };\n    QRCode.prototype.transformPixelLengthIntoNumberOfCells = function (pixelLength, cellSize) {\n        return pixelLength / cellSize;\n    };\n    QRCode.prototype.isCoordinateInImage = function (col, row, dWidthLogo, dHeightLogo, dxLogo, dyLogo, cellSize, logoImage) {\n        if (logoImage) {\n            var numberOfCellsMargin = 2;\n            var firstRowOfLogo = this.transformPixelLengthIntoNumberOfCells(dxLogo, cellSize);\n            var firstColumnOfLogo = this.transformPixelLengthIntoNumberOfCells(dyLogo, cellSize);\n            var logoWidthInCells = this.transformPixelLengthIntoNumberOfCells(dWidthLogo, cellSize) - 1;\n            var logoHeightInCells = this.transformPixelLengthIntoNumberOfCells(dHeightLogo, cellSize) - 1;\n            return row >= firstRowOfLogo - numberOfCellsMargin && row <= firstRowOfLogo + logoWidthInCells + numberOfCellsMargin // check rows\n                && col >= firstColumnOfLogo - numberOfCellsMargin && col <= firstColumnOfLogo + logoHeightInCells + numberOfCellsMargin; // check cols\n        }\n        else {\n            return false;\n        }\n    };\n    QRCode.prototype.shouldComponentUpdate = function (nextProps) {\n        return !isEqual(this.props, nextProps);\n    };\n    QRCode.prototype.componentDidMount = function () {\n        this.update();\n    };\n    QRCode.prototype.componentDidUpdate = function () {\n        this.update();\n    };\n    QRCode.prototype.update = function () {\n        var _a;\n        var _b = this.props, value = _b.value, ecLevel = _b.ecLevel, enableCORS = _b.enableCORS, bgColor = _b.bgColor, fgColor = _b.fgColor, logoImage = _b.logoImage, logoOpacity = _b.logoOpacity, logoOnLoad = _b.logoOnLoad, removeQrCodeBehindLogo = _b.removeQrCodeBehindLogo, qrStyle = _b.qrStyle, eyeRadius = _b.eyeRadius, eyeColor = _b.eyeColor, logoPaddingStyle = _b.logoPaddingStyle;\n        // just make sure that these params are passed as numbers\n        var size = +this.props.size;\n        var quietZone = +this.props.quietZone;\n        var logoWidth = this.props.logoWidth ? +this.props.logoWidth : 0;\n        var logoHeight = this.props.logoHeight ? +this.props.logoHeight : 0;\n        var logoPadding = this.props.logoPadding ? +this.props.logoPadding : 0;\n        var qrCode = qrGenerator(0, ecLevel);\n        qrCode.addData(this.utf16to8(value));\n        qrCode.make();\n        var canvas = (_a = this.canvasRef) === null || _a === void 0 ? void 0 : _a.current;\n        var ctx = canvas.getContext('2d');\n        var canvasSize = size + (2 * quietZone);\n        var length = qrCode.getModuleCount();\n        var cellSize = size / length;\n        var scale = (window.devicePixelRatio || 1);\n        canvas.height = canvas.width = canvasSize * scale;\n        ctx.scale(scale, scale);\n        ctx.fillStyle = bgColor;\n        ctx.fillRect(0, 0, canvasSize, canvasSize);\n        var offset = quietZone;\n        var positioningZones = [\n            { row: 0, col: 0 },\n            { row: 0, col: length - 7 },\n            { row: length - 7, col: 0 },\n        ];\n        ctx.strokeStyle = fgColor;\n        if (qrStyle === 'dots') {\n            ctx.fillStyle = fgColor;\n            var radius = cellSize / 2;\n            for (var row = 0; row < length; row++) {\n                for (var col = 0; col < length; col++) {\n                    if (qrCode.isDark(row, col) && !this.isInPositioninZone(row, col, positioningZones)) {\n                        ctx.beginPath();\n                        ctx.arc(Math.round(col * cellSize) + radius + offset, Math.round(row * cellSize) + radius + offset, (radius / 100) * 75, 0, 2 * Math.PI, false);\n                        ctx.closePath();\n                        ctx.fill();\n                    }\n                }\n            }\n        }\n        else if (qrStyle === 'fluid') {\n            var radius = Math.ceil(cellSize / 2);\n            for (var row = 0; row < length; row++) {\n                for (var col = 0; col < length; col++) {\n                    if (qrCode.isDark(row, col) && !this.isInPositioninZone(row, col, positioningZones)) {\n                        var roundedCorners = [false, false, false, false]; // top-left, top-right, bottom-right, bottom-left\n                        if ((row > 0 && !qrCode.isDark(row - 1, col)) && (col > 0 && !qrCode.isDark(row, col - 1)))\n                            roundedCorners[0] = true;\n                        if ((row > 0 && !qrCode.isDark(row - 1, col)) && (col < length - 1 && !qrCode.isDark(row, col + 1)))\n                            roundedCorners[1] = true;\n                        if ((row < length - 1 && !qrCode.isDark(row + 1, col)) && (col < length - 1 && !qrCode.isDark(row, col + 1)))\n                            roundedCorners[2] = true;\n                        if ((row < length - 1 && !qrCode.isDark(row + 1, col)) && (col > 0 && !qrCode.isDark(row, col - 1)))\n                            roundedCorners[3] = true;\n                        var w = (Math.ceil((col + 1) * cellSize) - Math.floor(col * cellSize));\n                        var h = (Math.ceil((row + 1) * cellSize) - Math.floor(row * cellSize));\n                        ctx.fillStyle = fgColor;\n                        ctx.beginPath();\n                        ctx.arc(Math.round(col * cellSize) + radius + offset, Math.round(row * cellSize) + radius + offset, radius, 0, 2 * Math.PI, false);\n                        ctx.closePath();\n                        ctx.fill();\n                        if (!roundedCorners[0])\n                            ctx.fillRect(Math.round(col * cellSize) + offset, Math.round(row * cellSize) + offset, w / 2, h / 2);\n                        if (!roundedCorners[1])\n                            ctx.fillRect(Math.round(col * cellSize) + offset + Math.floor(w / 2), Math.round(row * cellSize) + offset, w / 2, h / 2);\n                        if (!roundedCorners[2])\n                            ctx.fillRect(Math.round(col * cellSize) + offset + Math.floor(w / 2), Math.round(row * cellSize) + offset + Math.floor(h / 2), w / 2, h / 2);\n                        if (!roundedCorners[3])\n                            ctx.fillRect(Math.round(col * cellSize) + offset, Math.round(row * cellSize) + offset + Math.floor(h / 2), w / 2, h / 2);\n                    }\n                }\n            }\n        }\n        else {\n            for (var row = 0; row < length; row++) {\n                for (var col = 0; col < length; col++) {\n                    if (qrCode.isDark(row, col) && !this.isInPositioninZone(row, col, positioningZones)) {\n                        ctx.fillStyle = fgColor;\n                        var w = (Math.ceil((col + 1) * cellSize) - Math.floor(col * cellSize));\n                        var h = (Math.ceil((row + 1) * cellSize) - Math.floor(row * cellSize));\n                        ctx.fillRect(Math.round(col * cellSize) + offset, Math.round(row * cellSize) + offset, w, h);\n                    }\n                }\n            }\n        }\n        // Draw positioning patterns\n        for (var i = 0; i < 3; i++) {\n            var _c = positioningZones[i], row = _c.row, col = _c.col;\n            var radii = eyeRadius;\n            var color = void 0;\n            if (Array.isArray(radii)) {\n                radii = radii[i];\n            }\n            if (typeof radii == 'number') {\n                radii = [radii, radii, radii, radii];\n            }\n            if (!eyeColor) { // if not specified, eye color is the same as foreground, \n                color = fgColor;\n            }\n            else {\n                if (Array.isArray(eyeColor)) { // if array, we pass the single color\n                    color = eyeColor[i];\n                }\n                else {\n                    color = eyeColor;\n                }\n            }\n            this.drawPositioningPattern(ctx, cellSize, offset, row, col, color, radii);\n        }\n        if (logoImage) {\n            var image_1 = new Image();\n            if (enableCORS) {\n                image_1.crossOrigin = 'Anonymous';\n            }\n            image_1.onload = function (e) {\n                ctx.save();\n                var dWidthLogo = logoWidth || size * 0.2;\n                var dHeightLogo = logoHeight || dWidthLogo;\n                var dxLogo = ((size - dWidthLogo) / 2);\n                var dyLogo = ((size - dHeightLogo) / 2);\n                if (removeQrCodeBehindLogo || logoPadding) {\n                    ctx.beginPath();\n                    ctx.strokeStyle = bgColor;\n                    ctx.fillStyle = bgColor;\n                    var dWidthLogoPadding = dWidthLogo + (2 * logoPadding);\n                    var dHeightLogoPadding = dHeightLogo + (2 * logoPadding);\n                    var dxLogoPadding = dxLogo + offset - logoPadding;\n                    var dyLogoPadding = dyLogo + offset - logoPadding;\n                    if (logoPaddingStyle === 'circle') {\n                        var dxCenterLogoPadding = dxLogoPadding + (dWidthLogoPadding / 2);\n                        var dyCenterLogoPadding = dyLogoPadding + (dHeightLogoPadding / 2);\n                        ctx.ellipse(dxCenterLogoPadding, dyCenterLogoPadding, dWidthLogoPadding / 2, dHeightLogoPadding / 2, 0, 0, 2 * Math.PI);\n                        ctx.stroke();\n                        ctx.fill();\n                    }\n                    else {\n                        ctx.fillRect(dxLogoPadding, dyLogoPadding, dWidthLogoPadding, dHeightLogoPadding);\n                    }\n                }\n                ctx.globalAlpha = logoOpacity;\n                ctx.drawImage(image_1, dxLogo + offset, dyLogo + offset, dWidthLogo, dHeightLogo);\n                ctx.restore();\n                if (logoOnLoad) {\n                    logoOnLoad(e);\n                }\n            };\n            image_1.src = logoImage;\n        }\n    };\n    QRCode.prototype.render = function () {\n        var _a;\n        var qrSize = +this.props.size + (2 * +this.props.quietZone);\n        return React.createElement(\"canvas\", { id: (_a = this.props.id) !== null && _a !== void 0 ? _a : 'react-qrcode-logo', height: qrSize, width: qrSize, style: __assign({ height: qrSize + 'px', width: qrSize + 'px' }, this.props.style), ref: this.canvasRef });\n    };\n    QRCode.defaultProps = {\n        value: 'https://reactjs.org/',\n        ecLevel: 'M',\n        enableCORS: false,\n        size: 150,\n        quietZone: 10,\n        bgColor: '#FFFFFF',\n        fgColor: '#000000',\n        logoOpacity: 1,\n        qrStyle: 'squares',\n        eyeRadius: [0, 0, 0],\n        logoPaddingStyle: 'square'\n    };\n    return QRCode;\n}(React.Component));\nexports.QRCode = QRCode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcXJjb2RlLWxvZ28vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxjQUFjLG1CQUFPLENBQUMsb0VBQWdCO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLHlFQUFrQjtBQUM1QyxZQUFZLG1CQUFPLENBQUMsd0dBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SUFBeUk7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMseUJBQXlCO0FBQ3ZDLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QyxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUMsa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QyxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdJQUFnSSw2Q0FBNkMsMENBQTBDO0FBQ3RRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXFyY29kZS1sb2dvL2Rpc3QvaW5kZXguanM/MTA2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5RUkNvZGUgPSB2b2lkIDA7XG52YXIgaXNFcXVhbCA9IHJlcXVpcmUoXCJsb2Rhc2guaXNlcXVhbFwiKTtcbnZhciBxckdlbmVyYXRvciA9IHJlcXVpcmUoXCJxcmNvZGUtZ2VuZXJhdG9yXCIpO1xudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIFFSQ29kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUVJDb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFFSQ29kZShwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2FudmFzUmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUVJDb2RlLnByb3RvdHlwZS5kb3dubG9hZCA9IGZ1bmN0aW9uIChmaWxlVHlwZSwgZmlsZU5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FudmFzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBtaW1lVHlwZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHN3aXRjaCAoZmlsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdqcGcnOlxuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZSA9ICdpbWFnZS9qcGVnJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2VicCc6XG4gICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlID0gJ2ltYWdlL3dlYnAnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwbmcnOlxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlID0gJ2ltYWdlL3BuZyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVybCA9IHRoaXMuY2FudmFzUmVmLmN1cnJlbnQudG9EYXRhVVJMKG1pbWVUeXBlLCAxLjApO1xuICAgICAgICAgICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgICBsaW5rLmRvd25sb2FkID0gZmlsZU5hbWUgIT09IG51bGwgJiYgZmlsZU5hbWUgIT09IHZvaWQgMCA/IGZpbGVOYW1lIDogJ3JlYWN0LXFyY29kZS1sb2dvJztcbiAgICAgICAgICAgIGxpbmsuaHJlZiA9IHVybDtcbiAgICAgICAgICAgIGxpbmsuY2xpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUVJDb2RlLnByb3RvdHlwZS51dGYxNnRvOCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdmFyIG91dCA9ICcnLCBpLCBjO1xuICAgICAgICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoKGMgPj0gMHgwMDAxKSAmJiAoYyA8PSAweDAwN0YpKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID4gMHgwN0ZGKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhFMCB8ICgoYyA+PiAxMikgJiAweDBGKSk7XG4gICAgICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpKTtcbiAgICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDgwIHwgKChjID4+IDApICYgMHgzRikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhDMCB8ICgoYyA+PiA2KSAmIDB4MUYpKTtcbiAgICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDgwIHwgKChjID4+IDApICYgMHgzRikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEcmF3IGEgcm91bmRlZCBzcXVhcmUgaW4gdGhlIGNhbnZhc1xuICAgICAqL1xuICAgIFFSQ29kZS5wcm90b3R5cGUuZHJhd1JvdW5kZWRTcXVhcmUgPSBmdW5jdGlvbiAobGluZVdpZHRoLCB4LCB5LCBzaXplLCBjb2xvciwgcmFkaWksIGZpbGwsIGN0eCkge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICAvLyBBZGp1c3QgY29vcmRpbmF0ZXMgc28gdGhhdCB0aGUgb3V0c2lkZSBvZiB0aGUgc3Ryb2tlIGlzIGFsaWduZWQgdG8gdGhlIGVkZ2VzXG4gICAgICAgIHkgKz0gbGluZVdpZHRoIC8gMjtcbiAgICAgICAgeCArPSBsaW5lV2lkdGggLyAyO1xuICAgICAgICBzaXplIC09IGxpbmVXaWR0aDtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJhZGlpKSkge1xuICAgICAgICAgICAgcmFkaWkgPSBbcmFkaWksIHJhZGlpLCByYWRpaSwgcmFkaWldO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJhZGl1cyBzaG91bGQgbm90IGJlIGdyZWF0ZXIgdGhhbiBoYWxmIHRoZSBzaXplIG9yIGxlc3MgdGhhbiB6ZXJvXG4gICAgICAgIHJhZGlpID0gcmFkaWkubWFwKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICByID0gTWF0aC5taW4ociwgc2l6ZSAvIDIpO1xuICAgICAgICAgICAgcmV0dXJuIChyIDwgMCkgPyAwIDogcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByVG9wTGVmdCA9IHJhZGlpWzBdIHx8IDA7XG4gICAgICAgIHZhciByVG9wUmlnaHQgPSByYWRpaVsxXSB8fCAwO1xuICAgICAgICB2YXIgckJvdHRvbVJpZ2h0ID0gcmFkaWlbMl0gfHwgMDtcbiAgICAgICAgdmFyIHJCb3R0b21MZWZ0ID0gcmFkaWlbM10gfHwgMDtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHggKyByVG9wTGVmdCwgeSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHNpemUgLSByVG9wUmlnaHQsIHkpO1xuICAgICAgICBpZiAoclRvcFJpZ2h0KVxuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHNpemUsIHksIHggKyBzaXplLCB5ICsgclRvcFJpZ2h0KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgc2l6ZSwgeSArIHNpemUgLSByQm90dG9tUmlnaHQpO1xuICAgICAgICBpZiAockJvdHRvbVJpZ2h0KVxuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHNpemUsIHkgKyBzaXplLCB4ICsgc2l6ZSAtIHJCb3R0b21SaWdodCwgeSArIHNpemUpO1xuICAgICAgICBjdHgubGluZVRvKHggKyByQm90dG9tTGVmdCwgeSArIHNpemUpO1xuICAgICAgICBpZiAockJvdHRvbUxlZnQpXG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgc2l6ZSwgeCwgeSArIHNpemUgLSByQm90dG9tTGVmdCk7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSArIHJUb3BMZWZ0KTtcbiAgICAgICAgaWYgKHJUb3BMZWZ0KVxuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJUb3BMZWZ0LCB5KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEcmF3IGEgc2luZ2xlIHBvc2l0aW9uYWwgcGF0dGVybiBleWUuXG4gICAgICovXG4gICAgUVJDb2RlLnByb3RvdHlwZS5kcmF3UG9zaXRpb25pbmdQYXR0ZXJuID0gZnVuY3Rpb24gKGN0eCwgY2VsbFNpemUsIG9mZnNldCwgcm93LCBjb2wsIGNvbG9yLCByYWRpaSkge1xuICAgICAgICBpZiAocmFkaWkgPT09IHZvaWQgMCkgeyByYWRpaSA9IFswLCAwLCAwLCAwXTsgfVxuICAgICAgICB2YXIgbGluZVdpZHRoID0gTWF0aC5jZWlsKGNlbGxTaXplKTtcbiAgICAgICAgdmFyIHJhZGlpT3V0ZXI7XG4gICAgICAgIHZhciByYWRpaUlubmVyO1xuICAgICAgICBpZiAodHlwZW9mIHJhZGlpICE9PSAnbnVtYmVyJyAmJiAhQXJyYXkuaXNBcnJheShyYWRpaSkpIHtcbiAgICAgICAgICAgIHJhZGlpT3V0ZXIgPSByYWRpaS5vdXRlciB8fCAwO1xuICAgICAgICAgICAgcmFkaWlJbm5lciA9IHJhZGlpLmlubmVyIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByYWRpaU91dGVyID0gcmFkaWk7XG4gICAgICAgICAgICByYWRpaUlubmVyID0gcmFkaWlPdXRlcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sb3JPdXRlcjtcbiAgICAgICAgdmFyIGNvbG9ySW5uZXI7XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb2xvck91dGVyID0gY29sb3Iub3V0ZXI7XG4gICAgICAgICAgICBjb2xvcklubmVyID0gY29sb3IuaW5uZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2xvck91dGVyID0gY29sb3I7XG4gICAgICAgICAgICBjb2xvcklubmVyID0gY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHkgPSAocm93ICogY2VsbFNpemUpICsgb2Zmc2V0O1xuICAgICAgICB2YXIgeCA9IChjb2wgKiBjZWxsU2l6ZSkgKyBvZmZzZXQ7XG4gICAgICAgIHZhciBzaXplID0gY2VsbFNpemUgKiA3O1xuICAgICAgICAvLyBPdXRlciBib3hcbiAgICAgICAgdGhpcy5kcmF3Um91bmRlZFNxdWFyZShsaW5lV2lkdGgsIHgsIHksIHNpemUsIGNvbG9yT3V0ZXIsIHJhZGlpT3V0ZXIsIGZhbHNlLCBjdHgpO1xuICAgICAgICAvLyBJbm5lciBib3hcbiAgICAgICAgc2l6ZSA9IGNlbGxTaXplICogMztcbiAgICAgICAgeSArPSBjZWxsU2l6ZSAqIDI7XG4gICAgICAgIHggKz0gY2VsbFNpemUgKiAyO1xuICAgICAgICB0aGlzLmRyYXdSb3VuZGVkU3F1YXJlKGxpbmVXaWR0aCwgeCwgeSwgc2l6ZSwgY29sb3JJbm5lciwgcmFkaWlJbm5lciwgdHJ1ZSwgY3R4KTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIGRvdCBpbnNpZGUgYSBwb3NpdGlvbmFsIHBhdHRlcm4gem9uZS5cbiAgICAgKi9cbiAgICBRUkNvZGUucHJvdG90eXBlLmlzSW5Qb3NpdGlvbmluWm9uZSA9IGZ1bmN0aW9uIChjb2wsIHJvdywgem9uZXMpIHtcbiAgICAgICAgcmV0dXJuIHpvbmVzLnNvbWUoZnVuY3Rpb24gKHpvbmUpIHsgcmV0dXJuIChyb3cgPj0gem9uZS5yb3cgJiYgcm93IDw9IHpvbmUucm93ICsgNyAmJlxuICAgICAgICAgICAgY29sID49IHpvbmUuY29sICYmIGNvbCA8PSB6b25lLmNvbCArIDcpOyB9KTtcbiAgICB9O1xuICAgIFFSQ29kZS5wcm90b3R5cGUudHJhbnNmb3JtUGl4ZWxMZW5ndGhJbnRvTnVtYmVyT2ZDZWxscyA9IGZ1bmN0aW9uIChwaXhlbExlbmd0aCwgY2VsbFNpemUpIHtcbiAgICAgICAgcmV0dXJuIHBpeGVsTGVuZ3RoIC8gY2VsbFNpemU7XG4gICAgfTtcbiAgICBRUkNvZGUucHJvdG90eXBlLmlzQ29vcmRpbmF0ZUluSW1hZ2UgPSBmdW5jdGlvbiAoY29sLCByb3csIGRXaWR0aExvZ28sIGRIZWlnaHRMb2dvLCBkeExvZ28sIGR5TG9nbywgY2VsbFNpemUsIGxvZ29JbWFnZSkge1xuICAgICAgICBpZiAobG9nb0ltYWdlKSB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyT2ZDZWxsc01hcmdpbiA9IDI7XG4gICAgICAgICAgICB2YXIgZmlyc3RSb3dPZkxvZ28gPSB0aGlzLnRyYW5zZm9ybVBpeGVsTGVuZ3RoSW50b051bWJlck9mQ2VsbHMoZHhMb2dvLCBjZWxsU2l6ZSk7XG4gICAgICAgICAgICB2YXIgZmlyc3RDb2x1bW5PZkxvZ28gPSB0aGlzLnRyYW5zZm9ybVBpeGVsTGVuZ3RoSW50b051bWJlck9mQ2VsbHMoZHlMb2dvLCBjZWxsU2l6ZSk7XG4gICAgICAgICAgICB2YXIgbG9nb1dpZHRoSW5DZWxscyA9IHRoaXMudHJhbnNmb3JtUGl4ZWxMZW5ndGhJbnRvTnVtYmVyT2ZDZWxscyhkV2lkdGhMb2dvLCBjZWxsU2l6ZSkgLSAxO1xuICAgICAgICAgICAgdmFyIGxvZ29IZWlnaHRJbkNlbGxzID0gdGhpcy50cmFuc2Zvcm1QaXhlbExlbmd0aEludG9OdW1iZXJPZkNlbGxzKGRIZWlnaHRMb2dvLCBjZWxsU2l6ZSkgLSAxO1xuICAgICAgICAgICAgcmV0dXJuIHJvdyA+PSBmaXJzdFJvd09mTG9nbyAtIG51bWJlck9mQ2VsbHNNYXJnaW4gJiYgcm93IDw9IGZpcnN0Um93T2ZMb2dvICsgbG9nb1dpZHRoSW5DZWxscyArIG51bWJlck9mQ2VsbHNNYXJnaW4gLy8gY2hlY2sgcm93c1xuICAgICAgICAgICAgICAgICYmIGNvbCA+PSBmaXJzdENvbHVtbk9mTG9nbyAtIG51bWJlck9mQ2VsbHNNYXJnaW4gJiYgY29sIDw9IGZpcnN0Q29sdW1uT2ZMb2dvICsgbG9nb0hlaWdodEluQ2VsbHMgKyBudW1iZXJPZkNlbGxzTWFyZ2luOyAvLyBjaGVjayBjb2xzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFFSQ29kZS5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gKG5leHRQcm9wcykge1xuICAgICAgICByZXR1cm4gIWlzRXF1YWwodGhpcy5wcm9wcywgbmV4dFByb3BzKTtcbiAgICB9O1xuICAgIFFSQ29kZS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBRUkNvZGUucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIFFSQ29kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfYiA9IHRoaXMucHJvcHMsIHZhbHVlID0gX2IudmFsdWUsIGVjTGV2ZWwgPSBfYi5lY0xldmVsLCBlbmFibGVDT1JTID0gX2IuZW5hYmxlQ09SUywgYmdDb2xvciA9IF9iLmJnQ29sb3IsIGZnQ29sb3IgPSBfYi5mZ0NvbG9yLCBsb2dvSW1hZ2UgPSBfYi5sb2dvSW1hZ2UsIGxvZ29PcGFjaXR5ID0gX2IubG9nb09wYWNpdHksIGxvZ29PbkxvYWQgPSBfYi5sb2dvT25Mb2FkLCByZW1vdmVRckNvZGVCZWhpbmRMb2dvID0gX2IucmVtb3ZlUXJDb2RlQmVoaW5kTG9nbywgcXJTdHlsZSA9IF9iLnFyU3R5bGUsIGV5ZVJhZGl1cyA9IF9iLmV5ZVJhZGl1cywgZXllQ29sb3IgPSBfYi5leWVDb2xvciwgbG9nb1BhZGRpbmdTdHlsZSA9IF9iLmxvZ29QYWRkaW5nU3R5bGU7XG4gICAgICAgIC8vIGp1c3QgbWFrZSBzdXJlIHRoYXQgdGhlc2UgcGFyYW1zIGFyZSBwYXNzZWQgYXMgbnVtYmVyc1xuICAgICAgICB2YXIgc2l6ZSA9ICt0aGlzLnByb3BzLnNpemU7XG4gICAgICAgIHZhciBxdWlldFpvbmUgPSArdGhpcy5wcm9wcy5xdWlldFpvbmU7XG4gICAgICAgIHZhciBsb2dvV2lkdGggPSB0aGlzLnByb3BzLmxvZ29XaWR0aCA/ICt0aGlzLnByb3BzLmxvZ29XaWR0aCA6IDA7XG4gICAgICAgIHZhciBsb2dvSGVpZ2h0ID0gdGhpcy5wcm9wcy5sb2dvSGVpZ2h0ID8gK3RoaXMucHJvcHMubG9nb0hlaWdodCA6IDA7XG4gICAgICAgIHZhciBsb2dvUGFkZGluZyA9IHRoaXMucHJvcHMubG9nb1BhZGRpbmcgPyArdGhpcy5wcm9wcy5sb2dvUGFkZGluZyA6IDA7XG4gICAgICAgIHZhciBxckNvZGUgPSBxckdlbmVyYXRvcigwLCBlY0xldmVsKTtcbiAgICAgICAgcXJDb2RlLmFkZERhdGEodGhpcy51dGYxNnRvOCh2YWx1ZSkpO1xuICAgICAgICBxckNvZGUubWFrZSgpO1xuICAgICAgICB2YXIgY2FudmFzID0gKF9hID0gdGhpcy5jYW52YXNSZWYpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXJyZW50O1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHZhciBjYW52YXNTaXplID0gc2l6ZSArICgyICogcXVpZXRab25lKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHFyQ29kZS5nZXRNb2R1bGVDb3VudCgpO1xuICAgICAgICB2YXIgY2VsbFNpemUgPSBzaXplIC8gbGVuZ3RoO1xuICAgICAgICB2YXIgc2NhbGUgPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggPSBjYW52YXNTaXplICogc2NhbGU7XG4gICAgICAgIGN0eC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gYmdDb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1NpemUsIGNhbnZhc1NpemUpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcXVpZXRab25lO1xuICAgICAgICB2YXIgcG9zaXRpb25pbmdab25lcyA9IFtcbiAgICAgICAgICAgIHsgcm93OiAwLCBjb2w6IDAgfSxcbiAgICAgICAgICAgIHsgcm93OiAwLCBjb2w6IGxlbmd0aCAtIDcgfSxcbiAgICAgICAgICAgIHsgcm93OiBsZW5ndGggLSA3LCBjb2w6IDAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZmdDb2xvcjtcbiAgICAgICAgaWYgKHFyU3R5bGUgPT09ICdkb3RzJykge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZnQ29sb3I7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gY2VsbFNpemUgLyAyO1xuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbGVuZ3RoOyByb3crKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFyQ29kZS5pc0Rhcmsocm93LCBjb2wpICYmICF0aGlzLmlzSW5Qb3NpdGlvbmluWm9uZShyb3csIGNvbCwgcG9zaXRpb25pbmdab25lcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoTWF0aC5yb3VuZChjb2wgKiBjZWxsU2l6ZSkgKyByYWRpdXMgKyBvZmZzZXQsIE1hdGgucm91bmQocm93ICogY2VsbFNpemUpICsgcmFkaXVzICsgb2Zmc2V0LCAocmFkaXVzIC8gMTAwKSAqIDc1LCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChxclN0eWxlID09PSAnZmx1aWQnKSB7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5jZWlsKGNlbGxTaXplIC8gMik7XG4gICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBsZW5ndGg7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbGVuZ3RoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXJDb2RlLmlzRGFyayhyb3csIGNvbCkgJiYgIXRoaXMuaXNJblBvc2l0aW9uaW5ab25lKHJvdywgY29sLCBwb3NpdGlvbmluZ1pvbmVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdW5kZWRDb3JuZXJzID0gW2ZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlXTsgLy8gdG9wLWxlZnQsIHRvcC1yaWdodCwgYm90dG9tLXJpZ2h0LCBib3R0b20tbGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyb3cgPiAwICYmICFxckNvZGUuaXNEYXJrKHJvdyAtIDEsIGNvbCkpICYmIChjb2wgPiAwICYmICFxckNvZGUuaXNEYXJrKHJvdywgY29sIC0gMSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kZWRDb3JuZXJzWzBdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocm93ID4gMCAmJiAhcXJDb2RlLmlzRGFyayhyb3cgLSAxLCBjb2wpKSAmJiAoY29sIDwgbGVuZ3RoIC0gMSAmJiAhcXJDb2RlLmlzRGFyayhyb3csIGNvbCArIDEpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3VuZGVkQ29ybmVyc1sxXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJvdyA8IGxlbmd0aCAtIDEgJiYgIXFyQ29kZS5pc0Rhcmsocm93ICsgMSwgY29sKSkgJiYgKGNvbCA8IGxlbmd0aCAtIDEgJiYgIXFyQ29kZS5pc0Rhcmsocm93LCBjb2wgKyAxKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91bmRlZENvcm5lcnNbMl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyb3cgPCBsZW5ndGggLSAxICYmICFxckNvZGUuaXNEYXJrKHJvdyArIDEsIGNvbCkpICYmIChjb2wgPiAwICYmICFxckNvZGUuaXNEYXJrKHJvdywgY29sIC0gMSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kZWRDb3JuZXJzWzNdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ID0gKE1hdGguY2VpbCgoY29sICsgMSkgKiBjZWxsU2l6ZSkgLSBNYXRoLmZsb29yKGNvbCAqIGNlbGxTaXplKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IChNYXRoLmNlaWwoKHJvdyArIDEpICogY2VsbFNpemUpIC0gTWF0aC5mbG9vcihyb3cgKiBjZWxsU2l6ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZnQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKE1hdGgucm91bmQoY29sICogY2VsbFNpemUpICsgcmFkaXVzICsgb2Zmc2V0LCBNYXRoLnJvdW5kKHJvdyAqIGNlbGxTaXplKSArIHJhZGl1cyArIG9mZnNldCwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcm91bmRlZENvcm5lcnNbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KE1hdGgucm91bmQoY29sICogY2VsbFNpemUpICsgb2Zmc2V0LCBNYXRoLnJvdW5kKHJvdyAqIGNlbGxTaXplKSArIG9mZnNldCwgdyAvIDIsIGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcm91bmRlZENvcm5lcnNbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KE1hdGgucm91bmQoY29sICogY2VsbFNpemUpICsgb2Zmc2V0ICsgTWF0aC5mbG9vcih3IC8gMiksIE1hdGgucm91bmQocm93ICogY2VsbFNpemUpICsgb2Zmc2V0LCB3IC8gMiwgaCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyb3VuZGVkQ29ybmVyc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoTWF0aC5yb3VuZChjb2wgKiBjZWxsU2l6ZSkgKyBvZmZzZXQgKyBNYXRoLmZsb29yKHcgLyAyKSwgTWF0aC5yb3VuZChyb3cgKiBjZWxsU2l6ZSkgKyBvZmZzZXQgKyBNYXRoLmZsb29yKGggLyAyKSwgdyAvIDIsIGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcm91bmRlZENvcm5lcnNbM10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KE1hdGgucm91bmQoY29sICogY2VsbFNpemUpICsgb2Zmc2V0LCBNYXRoLnJvdW5kKHJvdyAqIGNlbGxTaXplKSArIG9mZnNldCArIE1hdGguZmxvb3IoaCAvIDIpLCB3IC8gMiwgaCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbGVuZ3RoOyByb3crKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFyQ29kZS5pc0Rhcmsocm93LCBjb2wpICYmICF0aGlzLmlzSW5Qb3NpdGlvbmluWm9uZShyb3csIGNvbCwgcG9zaXRpb25pbmdab25lcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmZ0NvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSAoTWF0aC5jZWlsKChjb2wgKyAxKSAqIGNlbGxTaXplKSAtIE1hdGguZmxvb3IoY29sICogY2VsbFNpemUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gKE1hdGguY2VpbCgocm93ICsgMSkgKiBjZWxsU2l6ZSkgLSBNYXRoLmZsb29yKHJvdyAqIGNlbGxTaXplKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoTWF0aC5yb3VuZChjb2wgKiBjZWxsU2l6ZSkgKyBvZmZzZXQsIE1hdGgucm91bmQocm93ICogY2VsbFNpemUpICsgb2Zmc2V0LCB3LCBoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEcmF3IHBvc2l0aW9uaW5nIHBhdHRlcm5zXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2MgPSBwb3NpdGlvbmluZ1pvbmVzW2ldLCByb3cgPSBfYy5yb3csIGNvbCA9IF9jLmNvbDtcbiAgICAgICAgICAgIHZhciByYWRpaSA9IGV5ZVJhZGl1cztcbiAgICAgICAgICAgIHZhciBjb2xvciA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhZGlpKSkge1xuICAgICAgICAgICAgICAgIHJhZGlpID0gcmFkaWlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJhZGlpID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmFkaWkgPSBbcmFkaWksIHJhZGlpLCByYWRpaSwgcmFkaWldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFleWVDb2xvcikgeyAvLyBpZiBub3Qgc3BlY2lmaWVkLCBleWUgY29sb3IgaXMgdGhlIHNhbWUgYXMgZm9yZWdyb3VuZCwgXG4gICAgICAgICAgICAgICAgY29sb3IgPSBmZ0NvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXllQ29sb3IpKSB7IC8vIGlmIGFycmF5LCB3ZSBwYXNzIHRoZSBzaW5nbGUgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBleWVDb2xvcltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gZXllQ29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kcmF3UG9zaXRpb25pbmdQYXR0ZXJuKGN0eCwgY2VsbFNpemUsIG9mZnNldCwgcm93LCBjb2wsIGNvbG9yLCByYWRpaSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvZ29JbWFnZSkge1xuICAgICAgICAgICAgdmFyIGltYWdlXzEgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIGlmIChlbmFibGVDT1JTKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VfMS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1hZ2VfMS5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGRXaWR0aExvZ28gPSBsb2dvV2lkdGggfHwgc2l6ZSAqIDAuMjtcbiAgICAgICAgICAgICAgICB2YXIgZEhlaWdodExvZ28gPSBsb2dvSGVpZ2h0IHx8IGRXaWR0aExvZ287XG4gICAgICAgICAgICAgICAgdmFyIGR4TG9nbyA9ICgoc2l6ZSAtIGRXaWR0aExvZ28pIC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIGR5TG9nbyA9ICgoc2l6ZSAtIGRIZWlnaHRMb2dvKSAvIDIpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVRckNvZGVCZWhpbmRMb2dvIHx8IGxvZ29QYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYmdDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJnQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkV2lkdGhMb2dvUGFkZGluZyA9IGRXaWR0aExvZ28gKyAoMiAqIGxvZ29QYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRIZWlnaHRMb2dvUGFkZGluZyA9IGRIZWlnaHRMb2dvICsgKDIgKiBsb2dvUGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeExvZ29QYWRkaW5nID0gZHhMb2dvICsgb2Zmc2V0IC0gbG9nb1BhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeUxvZ29QYWRkaW5nID0gZHlMb2dvICsgb2Zmc2V0IC0gbG9nb1BhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2dvUGFkZGluZ1N0eWxlID09PSAnY2lyY2xlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR4Q2VudGVyTG9nb1BhZGRpbmcgPSBkeExvZ29QYWRkaW5nICsgKGRXaWR0aExvZ29QYWRkaW5nIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlDZW50ZXJMb2dvUGFkZGluZyA9IGR5TG9nb1BhZGRpbmcgKyAoZEhlaWdodExvZ29QYWRkaW5nIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZWxsaXBzZShkeENlbnRlckxvZ29QYWRkaW5nLCBkeUNlbnRlckxvZ29QYWRkaW5nLCBkV2lkdGhMb2dvUGFkZGluZyAvIDIsIGRIZWlnaHRMb2dvUGFkZGluZyAvIDIsIDAsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoZHhMb2dvUGFkZGluZywgZHlMb2dvUGFkZGluZywgZFdpZHRoTG9nb1BhZGRpbmcsIGRIZWlnaHRMb2dvUGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gbG9nb09wYWNpdHk7XG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZV8xLCBkeExvZ28gKyBvZmZzZXQsIGR5TG9nbyArIG9mZnNldCwgZFdpZHRoTG9nbywgZEhlaWdodExvZ28pO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ29PbkxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nb09uTG9hZChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1hZ2VfMS5zcmMgPSBsb2dvSW1hZ2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFFSQ29kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBxclNpemUgPSArdGhpcy5wcm9wcy5zaXplICsgKDIgKiArdGhpcy5wcm9wcy5xdWlldFpvbmUpO1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiLCB7IGlkOiAoX2EgPSB0aGlzLnByb3BzLmlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAncmVhY3QtcXJjb2RlLWxvZ28nLCBoZWlnaHQ6IHFyU2l6ZSwgd2lkdGg6IHFyU2l6ZSwgc3R5bGU6IF9fYXNzaWduKHsgaGVpZ2h0OiBxclNpemUgKyAncHgnLCB3aWR0aDogcXJTaXplICsgJ3B4JyB9LCB0aGlzLnByb3BzLnN0eWxlKSwgcmVmOiB0aGlzLmNhbnZhc1JlZiB9KTtcbiAgICB9O1xuICAgIFFSQ29kZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHZhbHVlOiAnaHR0cHM6Ly9yZWFjdGpzLm9yZy8nLFxuICAgICAgICBlY0xldmVsOiAnTScsXG4gICAgICAgIGVuYWJsZUNPUlM6IGZhbHNlLFxuICAgICAgICBzaXplOiAxNTAsXG4gICAgICAgIHF1aWV0Wm9uZTogMTAsXG4gICAgICAgIGJnQ29sb3I6ICcjRkZGRkZGJyxcbiAgICAgICAgZmdDb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICBsb2dvT3BhY2l0eTogMSxcbiAgICAgICAgcXJTdHlsZTogJ3NxdWFyZXMnLFxuICAgICAgICBleWVSYWRpdXM6IFswLCAwLCAwXSxcbiAgICAgICAgbG9nb1BhZGRpbmdTdHlsZTogJ3NxdWFyZSdcbiAgICB9O1xuICAgIHJldHVybiBRUkNvZGU7XG59KFJlYWN0LkNvbXBvbmVudCkpO1xuZXhwb3J0cy5RUkNvZGUgPSBRUkNvZGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-qrcode-logo/dist/index.js\n");

/***/ })

};
;